Usually the [Sampler.setActiveGroup](/scripting/scripting-api/sampler#setactivegroup) function is all you need in order to programmatically set the round robin group. However there are a few edge cases where this function leads to inaccurate behaviour: if you play multiple notes pretty fast (we're talking about a few milliseconds between events), the MIDI event queue contains more than one note on message per audio buffer. In this case the internal processing order will override the active group index of the last API call before the voices get started. This might result in voices **being started with a different group index than it was set during the MIDI callback execution**.  
Usually this isn't problematic because the result is just that it will pick another RR group as desired and if you use this for actual round robin repetitions there is almost no perceivable change in the sound (because chances are great that notes that are being played this fast will be different notes which masks the machine gun effect we're trying to prevent here). 

However there are a few [use cases](https://forum.hise.audio//post/72501) where this becomes a problem so in order to ensure that the group index that you've set during the MIDI callback is guaranteed to be the one that is picked up by the voice allocation logic a few CPU cycles down the line, you will have to use this method instead which takes in the event ID of the message that is about to start the next voice and store it in a internal queue until the voice allocator will use it to set it to the exact group index you've specified here.

> This queue has a very limited lifetime and will get automatically cleared after each audio render callback of the sampler. This ensures that it won't stack up "unused" notes, but this also means that this procedure does not work with events that are not processed immediately (eg. because you've delayed them using `Message.delayEvent()` after calling this method).

The method also works with artificial notes and the internal event queue can store up to 64 note on messages (there's a tradeoff between object size and functionality here but with 64 messages within a single audio callback you should have enough headroom for even the most craziest applications).