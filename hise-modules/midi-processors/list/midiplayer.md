---
keywords: Midi Player
summary:  Autogenerated File
author:   Christoph Hart
modified: 18.03.2019
---

The MIDI player module is a generic MIDI file player that allows you to play MIDI loops in your project, record incoming MIDI notes and even provide the tools for processing MIDI files on the fly. 

## List of supported MIDI features

The MIDI player is far from being a 100% standard compliant MIDI player - it's intended to be a player for playing loops in your project that are synced to an external clock, so every time information (song tempo, tempo changes, time signatures and other meta events) are removed. Also there is no support for CC controllers or pitch wheel information yet, but these are just not implemented yet because out of laziness so if you need this, drop a post in the HISE forum and I'll put it to my queue...

## Using the MIDI player

If you load a MIDI player in the MIDI chain of a sound generator, you will notice that it will jump to the top of the processing chain. I will spare you the explanation of the technical background why this is necessary, just be aware of that fact, so if you need to "preprocess" events that go into the MIDI player, you need to put them in a parent's MIDI chain.

Then just drop some MIDI files onto the box that says **Drop MIDI files** and press the play button to hear the MIDI file in a loop.

Now after this "hello world experience", you might want to dive in into the more complex possibilities, which are covered along this chapter.

## MidiFile Pool

The MIDI files that you load into the MidiPlayer module will be pooled like AudioFiles, Images and SampleMaps so that they can be embedded into the compiled binary. All files in the `MidiFiles` project subfolder will be cached on project load (the file size is neglible unlike audio files or images so you don't need to call something like `Engine.loadAudioFilesIntoPool()`  explicitely.

You can hotswap different MIDI files even during playback and the player will try to retain the playback position as good as possible (wrapping the playback position around the new loop length if it's shorter than the previous file).

### MIDI tracks

A MIDI file can contain up to 16 MIDI tracks, however the MIDI player can just play one track at a time. If you want to play multiple tracks, just create another MIDI Player instance in another sound generator module (because chances are great you will want to play it with another sound) and choose the track index). Be aware that the track index is supposed to be a static property so hotswapping between different tracks is not supported (unlike hotswapping files).

## MIDI Player UI

If you load up the MIDI player, it will look pretty unimpressive. The reason is that the core player just handles the basic playback functionality and all UI features are separated into different UI components called **Midi Overlays** that provide more interesting features. Currently there are 3 overlays available:

- a simple drag and drop module
- a simple piano roll view
- a (somewhat weird and experimental) looper module that I've used to prototype the recording function.

All of them can be loaded into the `MidiOverlayPanel` floating tile so you can directly slap them onto your UI.

This list might get extended over time with additional modules, but if you can't wait, you can also implement your own UI by connecting a ScriptPanel to the MIDI player.

## Scripting API

A typed reference to a `MidiPlayer` module gives you additional methods to

1. Control the playback of the player with perfect sample accuracy
2. Perform MIDI processing on the files
3. Create custom UI Overlays by connecting it to a ScriptPanel which will be automatically updated on certain MIDI events.

### The MIDI Processing workflow

The MIDI Player module loads and plays MIDI files, but that is just the start: you can perform any kind of MIDI processing to the file after it was loaded using the same API calls that you would use for real time MIDI processing! The general workflow will always be the same three steps:

1. Get a list of events from the MIDI file. It will return an array of `MessageHolder` objects that have the same API as the `Message` class you know from MIDI processing live input
2. Iterate over the array and perform your processing. You can also delete events, but be aware that the `for(... in ...)` loop will not handle deletions well, so you need to resort to the `for(i=0; i < events.length; i++)` loop style.
3. Flush the operation (writes back the array into the MIDI file). This operation is fully undoable so you can revert it back to the previous state if something went wrong.

A minimal example for this process would be:

```javascript
// fetch a typed reference
const var MIDIPlayer1 = Synth.getMidiPlayer("MIDI Player1");

// 1. get a list
const var list = MIDIPlayer1.getEventList();

// 2. Perform operations
for(e in list)
{
    if(e.isNoteOn())
        e.setVelocity(36);
}

// 3. Flush the processed list back to the MIDI file
MIDIPlayer1.flushMessageList(list);
```

Be aware that while the processing array contains `HiseEvents`, the data will be stored as plain MIDI information when it's written back into the MIDI file, so you loose any special `HiseEvent` property like pitch fades, artificial state (and the transpose amount will be merged with the note number).

The timestamp will be using the current tempo and samplerate to be consistent with the rest of the MIDI processing in HISE. So if you have quarter notes at 44,1kHz and 120BPM, you will get these timestamps for the first bar:

```
0,
22050
44100
66150
```




```

