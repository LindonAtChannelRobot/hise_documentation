# The new Interface Designer

## Why?

The Interface Designer was a part of HISE for quite some time now and allowed editing of interface properties using a WYSIWYG editor in order to make some editing tasks more convenient. It was implemented by directly operating on the script code and replacing the content between some autogenerated comments with autogenerated code that looked like this:

```javascript
// [JSON ampSimPopupBg]
Content.setPropertiesFromJSON("ampSimPopupBg", {
  "width": 850,
  "height": 600,
  "visible": false
});
// [/JSON ampSimPopupBg]
```

In order to change the x,y position, it had to find this line:

```javascript
const var ampSimPopupBg = Content.addPanel("ampSimPopupBg", 101, 89);
```

and replace the numbers with the new position.  
Unfortunately this was not very scalable in terms of both performance (the regex operations that find these codes in big scripts slowed down the editing process) as well as maintainability - big scripts were cluttered with these autogenerated JSON code which made it hard to navigate in the code and find the stuff that really matters. Without making any actual measurements, it is safe to say that about 80% of the scripting code of a interface were these JSON thingies, which now can completely removed from the script code.
It also opposed some limitations on what the interface designer could do (multiple selection of components, changing the hierarchy, full undo for all property changes etc).



So while working on a big project the last months, I decided to redesign the entire thing and make it more scalable as well as more accessible for people who are not 100% fluent in coding Javascript.

I was being careful at the redesign to not break older projects. However the transition is not completely automatic. If you want to use the new interface designer on older projects you might need to change a few lines of code in order to support the new model. I'll sketch the most important things to do during a migration below. But first of all, we need to understand what has changed, so here is a brief overview of the new system.

## The Data model

Before going into the details, let's take a look at the abstract model that represents the Interface:

![model](http://hise.audio/images/tutorial/nid/Model.png)

Basically there are three entities which are created AND processed from left to right. The UI Data is restored with the instrument (just like the whole module structure), then it's processed by the script and all changes that are made here are written back to the UI Data and then the interface is being rendered based on the updated UI Data. Since this is a bit complicated, let's go through all three things in detail:

### The UI Data

Let's start with the biggest change. The UI Data is a tree structure that contains all non-default properties of each widget - you can think of it as if all JSON objects that were spread all over the code are bundled into one big organized chunk of uninteresting data and tucked away from the user (but you can still access the raw data with a few hacks of course).  
Instead of being a flat list, it is a tree that reflects the parent hierarchy of the interface (so child components are actually child elements).

There are a few advantages from separating the script code and the UI data:

- no more Regex madness. The interface designer can operate directly on the data without having to mangle the text content of the script code
- the parent component handling is much more robust if it's represented within a tree data structure.
- the UI model is persistent during compilation. If you type something stupid, your interface won't disappear.

#### Storage Location

If you're used to the old system, you probably wonder where the data is gone. It's important to know that the UI Data is not stored in the script. Instead it is written directly in the tree structure of the instrument (so either as XML subelement of the script processor or as binary tree in a .hip file). This means that the whole instrument has now this structure:

```
Container
 Interface (ScriptProcessor)
   Script
   UIData
   Control Values
 Sampler
   Velocity
   ...
```

Let's take a look at a simple example, which consists only of one slider. This is the XML element that represents the script processor:

```xml
<Processor Type="ScriptProcessor" ID="Interface" Bypassed="0" Script="Content.makeFrontInterface(600, 500);function onNoteOn()&#10;{&#10;&#9;&#10;}&#10;function onNoteOff()&#10;{&#10;&#9;&#10;}&#10;function onController()&#10;{&#10;&#9;&#10;}&#10;function onTimer()&#10;{&#10;&#9;&#10;}&#10;function onControl(number, value)&#10;{&#10;&#9;&#10;}&#10;">
  <EditorStates BodyShown="1" Visible="1" Solo="0" contentShown="1" onInitOpen="1"
                Folded="1"/>
  <ChildProcessors/>
  <Content>
    <Control type="ScriptSlider" id="Knob1" value="0"/>
  </Content>
  <UIData>
    <ContentProperties DeviceType="Desktop">
      <Component type="ScriptSlider" id="Knob1" x="37" y="17" width="128" height="48"/>
    </ContentProperties>
  </UIData>
</Processor>
```

As you can see, the terribly &#10mangled&1% script doesn't contain any information about the slider so if you load this script, the onInit callback is empty (apart from the `Content.makeFrontInterface()` call, obviously). Instead, the XML element contains a subelement called `UIData` which contains the data for each device type (this has implications for iOS, which is covered later on in the iOS chapter).

If you take a closer look, you'll see that the `Content` child element is exactly the thing that is stored as user preset. This is not new, but may be a bit distracting in this example.

> There are a few options in HISE to directly operate on the raw data. In this cases, this data is not represented in XML Format, but as JSON object in order to stay in Javascript world, so don't get too confused then :)

### The Script

After the UI data is created, the `onInit` callback (and subsequently the `onControl` callbacks of each persistent widgets) are executed and offer the possibility of changing the UI data using Javascript with either the `Widget.set()` or `Content.setPropertiesFromJSON()` methods.  
There is also the option of adding widgets using the `Content.addXXX()` methods, so basically you can still create your whole interface in pure Javascript and not touch the other stuff ever (but you would miss a lot of awesome things). 

However there is one big change: Once a widget is created using the Script methods, it will be stored in the UI model and from then on exist outside of the script engine, so if you delete this line of code, it doesn't mean that the widget will be deleted. **Instead, the script will just not get a reference to it**. If you call `Content.addXXX()` with an existing ID, **it actually won't create the widget again, but just return a reference to the existing data**.

> This behaviour resembles the way how script references to modules work. If you call `Synth.addModulator()`, it will create a modulator if the ID is not existing and just return a reference to the modulator if it's already there.

In order to remove elements, you can just select them and press the *Delete* key.

There is one problem, which will become more apparent in the Migration chapter below, and this is that while the `Content.addXXX()` methods will not duplicate the widget if you recompile them, it will still overwrite their position with the second and third argument which basically makes the positioning of the interface designer irrelevant. If you take a look at the diagram above, the script overwrites the properties from the UI Data (that's the red arrow). So if you drag the controls to their desired position, as soon as you recompile the script, it will jump back and be annoying. This is also the case for any property change from a script, which might become really hard to track down if they are buried deep somewhere in a random control callback. Luckily there is a feature in HISE that allows you to find these spots pretty quickly: as soon as the script is changing a property, it will disable the property in the editor and show a overlay that looks like this:

![](http://hise.audio/images/tutorial/nid/overwritten.png)

If you click on the **SHOW** button, it will take you exactly to the location in the code where the property change was called and you can safely remove the line of code (because it is stored in the UI Data already). This is obviously only true for static property changes, if you change eg. the visibility based on a button value, you obviously need the script line.

> If you're thinking: "But if I remove `const var Knob = Content.addKnob("Knob", 20, 20);`, I will not have a reference to this control, so how can I make any changes to it then?", you're right. For this case, there is the new `const var Knob = Content.getComponent("Knob");` line, which returns a reference to an already existing control.

## The Interface Designer Manual

The main advantage of this new system is that the workflow of the Interface Designer could be massively increased and allows building of complex interfaces entirely using the mouse / keyboard and limit the necessity of using the scripting engine only for certain tasks.

Below is a non-comprehensive list of things that are supposed to be done with either the Interface Designer or the Scripting Engine

Action | Interface Designer | Scripting Engine
------ | ------------------ | ----------------
**Building** | Adding / Removing Components | Customizing the appearance of ScriptPanels
**Properties** | Setting static Properties | Setting dynamic properties based on events
**Parameter Connection** | Connect widgets directly to a module parameter | Implement more complex connections (multiple parameters, inverted range, UI logic)

As you can see, with the new Interface Designer you'll get pretty far without knowing Javascript at all (and simple instruments should be doable without touching the code editor once).


![](http://hise.audio/images/tutorial/nid/InterfaceDesignerNew.png)

This is a screenshot of the current Interface Designer. If you're familiar with the old one, you've probably noticed that the only new panel is the **Widget List** to the left. However, let's go through every panel and take a look at every function as there are many hidden gems that I've added during the redesign.

### The Widget List

The widget list is a overview of the current interface structure. You can use it to select multiple elements (by holding either the Shift or Command modifier keys), drag them around to change the parent hierarchy or z-order, delete them or use a few other features from the context menu. You can also fold parent components and use the Search bar to quickly navigate to a control (which is particularly handy in complex interfaces for choosing the components you want to select)

Every item in this list represents one control and shows a few properties for a quick overview:

- controls which are restored when loading a user preset (`saveInPreset = true`) will have a green circle
- controls which are not persistent will have a red circle.
- controls which are invisible are greyed out
- controls which have a script reference have a {...} appended to their type ID. You can double click on them and the currently selected code editor will jump to the location of the definition.

#### Context Menu

Rightlicking on an item opens a context menu with the following functions:

Function | Description
-------- | -----------
**Create Script Variable Declaration** | Copies a code line that creates a reference for each selected item into the clipboard, eg:  `const var Knob1 = Content.getComponent("Knob1");`
**Create Custom Callback** | Copies a stub for a custom control callback for each selected item into the clipboard.
**Add Widget** | Adds a control of the specified type **as child component** of the selected item.

#### Changing the Parent hierarchy or z-order.

This is not a new feature (HISE already had a concept of parent-child relationships between components), however this panel with its tree view makes it really easy and obvious what's going on.

Basically you can add a widget as child of another widget in order to group them, and I highly recommend using this feature for any non-trivial interface. If you do so, the child coordinates will be relative to the parent component (so you can drag the parent around and the children will remain at their position within the parent), hiding the parent component also hides its children, etc. 

You can add a component as child simply by dragging it onto another widget like this:

![](http://hise.audio/images/tutorial/nid/ParentHierarchy.gif)

As you can see, dragging the Knob onto the Panel will also change its position because the x,y values will be relative to the Panels position instead of the origin.

You can also drag elements around to change their z-order, which is important if some elements are masked by others.

> If you do this, be aware that user presets are restored top-down, so if you change the z-order of controls which are dependant on each other, it might cause different behaviour.

#### Editing the raw JSON

Sometimes it is more convenient to directly edit the data in code format. For this task, there is a handy popup editor which shows a JSON list of all selected elements. Press **J** to open the popup, make the changes and hit **F5** to apply these changes and close the editor (Press the close button to cancel the edit):

![](http://hise.audio/images/tutorial/nid/RawJSON.gif)

> Unlike dragging and deleting components, editing the raw data has no undo / redo support so make sure you don't do anything stupid there.

### The Canvas

In the middle of the window is the Canvas, which is a preview of the interface that can be edited graphically. The most interesting addition is definitely the ability of selecting multiple elements and changing all their properties at once.

#### Toolbar

At the top of the canvas you'll find a toolbar that contains a few important tools for the entire Interface designer, so I'll start with explaining these first.

Function | Shortcut | Description
-------- | -------- | -----------
Toggle Edit / Play mode | **F4** | Toggles the canvas between play mode (where you can actually use the widgets) and edit mode where you can edit them and drag them around.
Deselect current item | **Escape** | Deselects all items
Zoom selector | **Cmd + / Cmd -** | Change the zoom amount from 50% to 200%.
Undo | **Cmd + Z** | Undo the last property change. This is using the global undo manager, so it also undoes drag operations in the *Widget List* or property changes in the *Property Editor*.
Redo | **Cmd + Y** | Same as undo says Captain Obvious.
Rebuild Interface | F5 | Refreshes the UI model.

The only thing that is not self explanatory is the last button so let's dig a bit deeper to see why this is important (and believe me, you will need to use that button a lot).  
Basically the UI model sketched above is a simplification and internally, HISE uses another layer called *ScriptComponent*, which are wrappers around the data model for each control. They store a reference to the data and communicate between the actual GUI you see and the script / UI model.  
However, in some cases, their connections breaks up and you wind up with a broken interface which looks pretty bad, but can easily be solved by simply deleting all of those wrappers and recreating them from the UI model, which is precisely what this button is doing.

In order to see its effect in full glory, follow these steps:

1. Create a Knob
2. Delete the control
3. Press the Undo button

As you can see, the Widget List shows the previously deleted Knob, but the Canvas is still empty. This is because the Widget List is directly displaying the data, while the Canvas depends on the wrapper thingie that got deleted (but wasn't restored because the undo operations just modify the actual data). If you press the **Rebuild Interface** button, the Knob will appear back.

This is a rather simple example (and to be honest, I could also just fix this so that undoing a delete automatically recreates the wrappers), but it's very unlikely that the same thing won't happen under more complicated conditions, so it's good to have this tool at hand. So bottom line, if the interface is behaving weird, just press this button and see if it fixes it.

> If you rebuild the interface, the script will not automatically be recompiled, so in order to make a full reset, you need to rebuild the interface first, then hit recompile.

Now that we know what the toolbar can do, we can take a look at the core functions of the canvas and how to use them effectively, namingly selecting elements and changing their position / size.

#### Selecting elements

You can select an element either by directly clicking on it or drag a lasso around all controls you want to modify. If you hold down the Command key while clicking on an element, it will add it to the selection. In order to deselect all elements, just press the **Escape** key.

> If you click on an already selected item, it will not be deselected. Instead it will grab the keyboard focus so that you can use the arrow keys to nudge it around (see below).

#### Changing the position / size

You can change the position and size of the currently selected items by either just dragging them around or resizing them although resizing doesn't work here with multiple elements. 

> If you need to resize multiple elements at once, you'll need the property panel or the arrow keys

When the canvas has the keyboard focus, you can use the arrow keys for nudging them around. The modifier keys can be used here to change the action. Their effect is similar for both keyboard and mouse interaction, but here is a detailed overview:

Modifier Key | Effect with Keystroke | Effect when dragging
------------ | --------------------- | --------------------
**Cmd / Ctrl** | Use a 10px raster | Use a 10px raster
**Shift** | Change the size instead of the position | Restrict the movement to horizontal / vertical only
**Alt** | nothing | Duplicating the current control

These modifier keys can be combined, so eg. pressing **Shift + Cmd * Right-Key** will increase the width by 10 pixel.  
The changes you make with the arrow keys are completely relative (so you can move / resize a selection without messing up their relation), which makes it the go-to solution for changing the position of multiple elements at once.

### The Property Editor

This panel can be used to change the properties of the currently selected items (again with full undo support).

#### Changing the ID

The textbox at the top row can be used to change the ID of the element. Since all elements are called something like `ScriptPanel23` when they are created, using this in order to give it a better name should be the first thing that you'll do.

> Remember that the ID is ridiculously important for almost everything - preset restoring, creating references to scripts, resolving the parent hierarchy etc. So for your own sanity pick a good name for each control once and try to stick to it because changing the ID of a control will become more and more painful over the time. Also it should be self explanatory that you can't use the same ID twice.

As soon as you have selected multiple elements, this text box becomes disabled. If you ask yourself why, just reread the paragraph above and focus on the last sentence :)


#### Changing the properties

The rest of the panel is a list of all properties that define this control. Each property has a approriate control type, eg. Sliders for the position or toggle buttons for boolean properties.

As soon as you have selected multiple elements, changing the property will set all controls to the given value (with the exception of the position sliders which operate relatively). If the selection has varying values for a property, it will show an asterisk **(*)** instead of the real value indicating that you need to be careful when changing this property (although there's still undo...)

Below you can find a list of all properties that are shared by every control type (there are many additional properties for every control), but listing these should be enough (the special properties are mostly self explanatory).

Property | Type | Default Value | Description
-------- | ---- | ------------- | -----------
`text` | String | the ID of the control | The name or text that is being displayed. How this text is exactly shown (or if it's used at all) depends on the control type.
`enabled`| Boolean | true | If the control should react on mouse events. Child components will inherit this property.
`visible` | Boolean | true | If the control is displayed or hidden. Child components will inherit this property.
`tooltip` | String | Empty | A informative text that will popup if you hover over the control.
`useUndoManager` | Boolean | false | If enabled, value changes can be undone with the scripting calls `Engine.undo()`
`macroControl` | Number (1-8) | -1 | Connect this control to a macro control slot.
`saveInPreset` | Boolean | Depends on the type | If true, this control will be saved in a user preset as well as restored on recompilation. If false, controls will not be stored in the preset and their control callback will not be fired after compilation. This is a very important property and you definitely need to know when to use it.
`isPluginParameter` | Boolean | false | If enabled, it exposes this control to a DAW for host automation.
`pluginParameterName` | String | Empty | If this control is a plugin parameter, it will use this name for displaying in the host.
`processorId` | Module ID | Empty | The module that is controlled by this control
`parameterId` | Parameter ID | Empty | the parameter ID of the module specified above that should be controlled. Use these two properties in order to hook up the control to a single parameter using the exact same range you specified below. As soon as you need something more complex, you need to use the scripting callbacks for it.
`x`, `y`, `width`, `height` | Number | Various | The absolute pixel position / size of the control. You can use the sliders to change them relatively or just input a number into the text field to set all selected controls to the same value.
`bgColour`, `itemColour`, `itemColour2`, `textColour` | String or hex number | Various | the colours for the given control. How these colours are used differs between the control types, but in most cases, `bgColour` is the background colour and `textColour` is used for rendering the text, otherwise it would be a bit weird.

#### Bonus-Level: Copying multiple properties to a selection

In many cases you will end up with a lot of (almost) duplicated controls: most of the time, all your knobs will share the same filmstrip or the buttons will have the same background colour. If you're smart, you're selecting all controls and set their common property once, but sometimes this is not possible (because you're adding new controls and don't want to mess with the old ones). Also if you need to set multiple properties, you need to do this for every property.
Luckily, there is a smarter solution and that is the possibility to paste the value of multiple properties at once to a whole selection. This can be done using the buttons next to the ID label:

1. Select one control and set all its properties how you need them.
2. Now select the properties by clicking on the property name. You'll notice it will be highlighted. Use the usual modifier keys for selecting multiple properties.
3. Click on the **Copy** button to create a JSON containing all selected properties with their value (paste it in the code editor to check what's happening before doing the next step)
4. Select all controls that you want to paste the property selection
5. Click on the **Paste** button and all selected properties will be pasted for the entire selection.


## Migrating older projects

If you've read until here, I hope you've understood the advantages of the new system and are eager to try it on your projects. However as stated before, it was a rather intrusive redesign, so any project that was created using the old system needs to be modified in order to fully use the benefits of the new system.

However, nothing should be broken. If you load up the old project, it should look the same and behave the same. If it doesn't, try rebuilding the interface and recompiling. But if you select a control, you will hardly be able to change any interesting property (and if you change its position), it will jump back as soon as you compile (like described above).

Basically there are three things that need to be taken care of manually: creation of widgets, JSON objects and factory methods.

> Important: Before you start migrating the projects, make sure that every control is there and is working correctly.

### Widget creation

Let's start with the most annoying step (it gets more fun later on). You need to replace every `Content.addXXX()` method with a call to `Content.getComponent()` in order to liberate their x,y-position. To make this a little bit less painful, I added a helper function in the code editor context menu that transforms the line automatically. Just select the line and use the **Replace Widget with Content.addKnob()** command:

```javascript
// this
const var Knob = Content.addKnob("Knob", 0, 0);

// will become this:
const var Knob = Content.getComponent("Knob");
```


### JSON objects from the old Interface Designer

Now it gets very complicated. Just kidding, delete them. Seriously, this is awesome. Since the properties are stored in the UI data model, setting them again using these annoying JSON objects is totally useless (and counterproductive because of *"Overwritten by script"*). This might sound like a lot of work, but actually it should not take you more than 3-5 enjoyable minutes for even large scale projects. Also the reduction of script code alone should make you think it's worth the effort.

### Factory methods

This last step needs a little bit more brain cells than the last one. A very handy (and still recommended) paradigm in HISE is to use Factory methods for creating / customizing controls (and especially for the ScriptPanel it is almost obligatory). Migrating Factory methods requires both steps from above and with a little bit of luck, they can simply be deleted completely because they got redudant with the new system:

1. Change the Widget creation. Normally every well-formed factory method starts with `local widget = Content.addXXX(name, x, y);`. Just replace it with `local widget = Content.getComponent(name);` using the same command.
2. Delete the JSON object. If there is nothing left in the factory function, you can delete the whole thing (this is the case for most factory functions for Sliders, Buttons, etc). However if your Factory method is creating a custom ScriptPanel, it's most likely that there are callback definitions which still need to be used.

Let's go through this process with a example factory method taken from the MusicBox example (the preset button that switches the user presets). This is the factory method before the rewrite:

```javascript
inline function createPresetButton(name, x, y, up)
{
  local widget = Content.addPanel(name, x, y);
    
  Content.setPropertiesFromJSON(name, {
    "width": 20,
    "height": 20,
    "saveInPreset": false,
    "tooltip": up ? "Load next user preset" : "Load previous user preset",
    "allowCallbacks": "Clicks & Hover"
  });
    
  widget.data.up = up;
    
  widget.setPaintRoutine(function(g)
  {
    g.setColour(this.data.hover ? 0xFFFFFFFF : 0x88FFFFFF);
    g.fillTriangle([0, 0, this.getWidth(), this.getHeight()], this.data.up ? Math.PI/2 : 1.5 * Math.PI);
  });
    
  widget.setMouseCallback(function(event)
  {
    this.data.hover = event.hover;
     
    if(event.clicked)
    {
      if(this.data.up)
        Engine.loadNextUserPreset(true);
      else
        Engine.loadPreviousUserPreset(true);    
    }
      
    this.repaint();
  });
  return widget;
};
```

and this is it after the migration:

```javascript
inline function createPresetButton(name, x, y, up)
{
  local widget = Content.getComponent(name);
    widget.data.up = up;
    
  widget.setPaintRoutine(function(g)
  {
    g.setColour(this.data.hover ? 0xFFFFFFFF : 0x88FFFFFF);
    g.fillTriangle([0, 0, this.getWidth(), this.getHeight()], this.data.up ? Math.PI/2 : 1.5 * Math.PI);
  });
    
  widget.setMouseCallback(function(event)
  {
    this.data.hover = event.hover;
     
    if(event.clicked)
    {
      if(this.data.up)
        Engine.loadNextUserPreset(true);
      else
        Engine.loadPreviousUserPreset(true);    
    }
      
    this.repaint();
  });
  return widget;
};
```

Please note that I didn't change the argument order despite that the `x` and `y` parameters are used nowhere anymore. It is not the cleanest solution, but this spares you the effort of going to every call to this function and updating the argument order. But you're free to decide for yourself if that's worth the additional work.

## iOS

A really nice fallout of this new system is that it allows to use different UI data models for each iOS device type. Just switch the device simulator to another device and choose **Tools -> Copy UI Data from Desktop** and it will clone the current Desktop interface into a new UI data model for this particular device type that can be modified to suit the different screen size.

> Make sure that if you have some controls that are only used in a certain device type that you'll tuck them away behind a `Engine.getDeviceType()` call before using them or you'll get trouble when compiling the script.






